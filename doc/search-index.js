var searchIndex = {};
searchIndex['bio'] = {"items":[[0,"","bio","# Rust-bio, a rusty bioinformatics library."],[0,"io","","Parsers for important file formats."],[0,"fastq","bio::io","An iterable FASTQ parser. The io modules of Rust are currently rewritten.\nHence, this modules will be subject to changes soon."],[3,"Record","bio::io::fastq","A FASTQ record, returned by the FASTQ parser."],[12,"name","","",0],[12,"seq","","",0],[12,"qual","","",0],[3,"FastqFile","",""],[11,"new","","Create a new FASTQ parser object.",1],[6,"Item","",""],[11,"next","","",1],[0,"utils","bio","Common utilities."],[5,"trim_newline","bio::utils",""],[5,"scan","","Inplace implementation of scan over a slice."],[5,"prescan","",""],[0,"alphabets","bio","Handling different alphabets."],[3,"Alphabet","bio::alphabets","Representation of an alphabet."],[12,"symbols","","",2],[3,"RankTransform","",""],[12,"ranks","","",3],[5,"get_dna_alphabet","","Obtain the DNA alphabet."],[5,"get_iupac_dna_alphabet","","Obtain the IUPAC DNA alphabet"],[6,"SymbolRanks","",""],[11,"new","","",2],[11,"from_iter","","",2],[11,"is_word","","",2],[11,"max_symbol","","",2],[11,"len","","",2],[11,"new","","",3],[11,"transform","","",3],[11,"get_alphabet","","",3],[0,"pattern_matching","bio","This module contains various useful pattern matching algorithms.\nThe implementations are based on the lecture notes\n\"Algorithmen auf Sequenzen\", Kopczynski, Marschall, Martin and Rahmann, 2008 - 2015."],[0,"shift_and","bio::pattern_matching","ShiftAnd algorithm for pattern matching.\nPatterns may contain at most 64 symbols.\nComplexity: O(n) with text length n."],[3,"ShiftAnd","bio::pattern_matching::shift_and",""],[3,"ShiftAndMatches","",""],[5,"get_masks","",""],[11,"new","","Create new ShiftAnd instance.",4],[11,"find_all","","Find all occurences of pattern in the given text.",4],[6,"Item","",""],[11,"next","","",5],[0,"kmp","bio::pattern_matching","Algorithm of Knuth Morris and Pratt.\nConstructs an automaton recognizing the pattern, and scans linearly over\na text of length n. Complexity: O(n). Here, the automaton is implemented\nby directly storing the transition function delta in a table for each state\nand symbol in the alphabet.\nFor this, it uses the lps-function, that assigns to each position q in the\npattern the longest prefix of the pattern that is suffix of pattern[..q+1].\nThen, in the NFA for the pattern, active states after reading position q are\n{q, lps(q), lps(lps(q)), ... 0}."],[3,"KMP","bio::pattern_matching::kmp",""],[3,"KMPMatches","",""],[11,"new","","",6],[11,"find_all","","",6],[6,"Item","",""],[11,"next","","",7],[0,"bom","bio::pattern_matching","Backward oracle matching algorithm.\n \n# Example"],[3,"BOM","bio::pattern_matching::bom",""],[3,"BOMMatches","",""],[11,"new","","",8],[11,"find_all","","Find all exact occurrences of the pattern in the given text.",8],[6,"Item","",""],[11,"next","","",9],[0,"horspool","bio::pattern_matching","Algorithm of Horspool.\nWindow-based, similar to but faster than Boyer-Moore."],[3,"Horspool","bio::pattern_matching::horspool",""],[3,"HorspoolMatches","",""],[11,"new","","",10],[11,"find_all","","",10],[6,"Item","",""],[11,"next","","",11],[0,"bndm","bio::pattern_matching","Backward nondeterministic DAWG matching (BNDM).\nBest-case complexity: O(n / m) with pattern of length m <= 64 and text of length n.\nWorst case complexity: O(n * m)."],[3,"BNDM","bio::pattern_matching::bndm",""],[3,"BNDMMatches","",""],[11,"new","","",12],[11,"find_all","","",12],[6,"Item","",""],[11,"next","","",13],[0,"data_structures","bio","Various useful data structures."],[0,"rank_select","bio::data_structures","Rank/Select data structure based on Gonzalez, Grabowski, MÃ¤kinen, Navarro (2005).\nThis implementation uses only a single level of blocks, and performs well for large n."],[3,"RankSelect","bio::data_structures::rank_select",""],[11,"new","","Create a new instance.",14],[11,"rank","","Get the rank of a given bit.\nComplexity: O(k).",14],[11,"select","","Get the smallest bit with a given rank.\nComplexity: O(log (n / k) + k).",14],[0,"suffix_array","bio::data_structures","Suffix arrays and related algorithms."],[5,"get_suffix_array","bio::data_structures::suffix_array","Construct suffix array for given text of length n.\nComplexity: O(n).\nThis is an implementation of the induced sorting as presented by \nGe Nong, Sen Zhang und Wai Hong Chan (2009), also known as SAIS.\nThe implementation is based on the following lecture notes:\nhttp://ls11-www.cs.tu-dortmund.de/people/rahmann/algoseq.pdf"],[5,"get_lcp","","Construct lcp array for given text and suffix array of length n.\nComplexity: O(n)."],[6,"SuffixArray","",""],[6,"LCPArray","",""],[0,"bwt","bio::data_structures","The Burrows-Wheeler-Transform and related data structures."],[3,"FMIndex","bio::data_structures::bwt",""],[3,"Occ","",""],[5,"get_bwt","","Calculate Burrows-Wheeler-Transform of the given text of length n.\nComplexity: O(n)."],[5,"get_inverse","","Calculate the inverse of a BWT of length n, which is the original text.\nComplexity: O(n)."],[6,"BWT","",""],[11,"new","","",15],[11,"backward_search","","Perform backward search, yielding suffix array\ninterval denoting positions where the given pattern occurs.",15],[11,"new","","Calculate occ array with sampling from BWT of length n.\nTime complexity: O(n).\nSpace complexity: O(n / k * A) with A being the alphabet size.\nAlphabet size is determined on the fly from the BWT.\nFor large texts, it is therefore advisable to transform\nthe text before calculating the BWT (see alphabets::rank_transform).",16],[11,"get_occ","","",16],[0,"alignment","bio","Alignment algorithms."],[3,"Alignment","bio::alignment",""],[12,"score","","",17],[12,"i","","",17],[12,"j","","",17],[12,"operations","","",17],[4,"AlignmentOperation","",""],[13,"Match","","",18],[13,"Subst","","",18],[13,"Del","","",18],[13,"Ins","","",18],[0,"pairwise","","Calculate alignments with a generalized variant of the Smith Waterman algorithm.\nComplexity: O(n * m) for strings of length m and n."],[3,"Aligner","bio::alignment::pairwise",""],[11,"with_capacity","","Create new aligner instance. The size hints help to\navoid unnecessary memory allocations.",19],[11,"global","","Calculate global alignment.",19],[11,"semiglobal","","Calculate semiglobal alignment.",19],[11,"local","","Calculate local alignment.",19],[11,"fmt","bio::alignment","",18],[11,"eq","","",18],[11,"ne","","",18],[11,"fmt","","",17],[0,"bitencoding","bio","A fixed-width bit encoding implementation."],[3,"BitEnc","bio::bitencoding",""],[12,"storage","","",20],[3,"BitEncIter","",""],[11,"new","","",20],[11,"with_capacity","","",20],[11,"push","","",20],[11,"push_values","","",20],[11,"set","","",20],[11,"get","","",20],[11,"iter","","",20],[11,"clear","","",20],[11,"len","","",20],[6,"Item","",""],[11,"next","","",21]],"paths":[[3,"Record"],[3,"FastqFile"],[3,"Alphabet"],[3,"RankTransform"],[3,"ShiftAnd"],[3,"ShiftAndMatches"],[3,"KMP"],[3,"KMPMatches"],[3,"BOM"],[3,"BOMMatches"],[3,"Horspool"],[3,"HorspoolMatches"],[3,"BNDM"],[3,"BNDMMatches"],[3,"RankSelect"],[3,"FMIndex"],[3,"Occ"],[3,"Alignment"],[4,"AlignmentOperation"],[3,"Aligner"],[3,"BitEnc"],[3,"BitEncIter"]]};
initSearch(searchIndex);
